%!TEX root=main.tex

\section{Concepts fondamentaux de théorie des jeux}
Dans le cadre de notre projet, nous sommes intéressés par les jeux sur graphes où tous les joueurs ont un \textit{objectif d'atteignabilité}.
Dans cette section, nous abordons la notion de jeux sur graphe de manière générale ainsi que les concepts fondamentaux liés à la théorie des jeux tels que les notions de stratégies, d'équilibres de Nash, ...\\
Cette section sera essentiellement inspirée de l'article de Brihaye et al. \cite{DBLP:conf/lfcs/BrihayePS13}.

\subsection{Jeux sur graphe}


% Définition d'arène


\begin{defi}[Arène]
	Soit $\Pi$ un ensemble (fini) de joueurs. On appelle \textit{arène} le tuple suivant :\\
	 $\mathcal{A} = (\Pi,V , (V_{i})_{i\in{\Pi}}, E )$ où :
	\begin{enumerate}
		\item[$\bullet$] $G = (V,E)$ est un \textit{graphe orienté}  dont $V$ est l'ensemble (fini) de ses sommets (\textit{vertex}) et $E \subseteq V \times V$ est l'ensemble de ses arcs (\textit{edge}). De plus, pour tout $ v\in V $ il existe $v'\in V$ tel que $(v,v') \in E$ (ie: pour tout sommet dans le graphe, il existe un arc sortant de ce sommet).
		\item[$\bullet$] $(V_{i})_{i\in\Pi}$ est une partition de l'ensemble des sommets du graphe $G$ telle que $V_{i}$ est l'ensemble des sommets du joueur $i$.
	\end{enumerate}
\end{defi}

%Définition de jeu sur graphe

\begin{defi}[Jeu sur graphe]
	Un \textit{jeu sur graphe}, noté $\mathcal{G}$ est la donnée d'une arène $\mathcal{A}$ et d'un \textit{objectif} pour chaque joueur.
\end{defi}

\begin{rem}
	Dans le cadre de ce document, les objectifs qui nous intéressent sont les \textit{objectifs d'atteignabilité}. Cette notion est abordée plus amplement dans la section \ref{sect:jeuxAtt}.
\end{rem}

\begin{rem}[Jeu initialisé]\label{sommetInit}
	Dans certains types de jeux sur graphe, on considère que le jeu commence à partir d'un \textit{sommet initial} donné. On le note communément $v_{0}$. Soit $\mathcal{G}$ un tel jeu, on note alors $(\mathcal{G},v_{0})$ le jeu ayant pour sommet initial $v_{0}$. On appelle $(\mathcal{G},v_{0})$ un \textit{jeu initialisé}.
\end{rem}

\begin{notations}
	Tout au long de ce rapport nous utilisons les conventions suivantes :
	\begin{enumerate}
		\item[$\bullet$] Soit $\mathcal{G}$ un jeu sur graphe, on note $(\mathcal{G},v_{0})$ le jeu ayant $v_{0}$ comme sommet initial .
		
		\item[$\bullet$] On note $J_{i}$  le joueur $i$.
		
		\item[$\bullet$] Pour $i\in \Pi$, on note : $-i\equiv \Pi\backslash \{ i\} $.
	\end{enumerate}
\end{notations}

%---------------------------------------
%Déroulement d'une partie d'un jeu sur graphe
%----------------------------------------


\noindent\textbf{Déroulement d'une partie}\label{derPar}

Nous pouvons imaginer le déroulement d'une partie d'un jeu sur graphe de la manière suivante: pour commencer un jeton est positionné sur un sommet $v_{0}$ du graphe (le sommet initial dans le cas de la remarque \ref{sommetInit}). Ensuite, comme ce sommet appartient à un certain $V_{i}$, le joueur $i$ choisit une arête $(v_{0},v_{1}) \in E$ et fait "glisser" le jeton le long de l'arc vers le sommet $v_{1}$. Ce sommet $v_{1}$ appartient à un certain $V_{j}$, c'est donc au joueur $j$ de choisir une arête $(v_{1},v_{2})\in E$ du graphe et faire "glisser" le jeton le long de cette arête. Le jeu se poursuit de la sorte infiniment. \\


\subsection{Stratégie}



%--------------------------------------
%Notions de chemin/jeu
%--------------------------------------

\noindent\textbf{Notions de chemin et de jeu}

\todo{Vérifier que j'utilise bien toutes les notions que je définis.}\\

Un \textit{jeu} $\rho \in V^{\omega}$(respectivement une \textit{histoire} $h \in V^{*}$) dans $\mathcal{A}$ est un chemin infini (respectivement fini) à travers le graphe. Nous noterons $\epsilon$ l'histoire vide, \textit{Plays} l'ensemble des jeux dans $\mathcal{A}$ et \textit{Hist} l'ensemble des histoires. Nous utiliserons les notations suivantes $\rho = \rho _{0}  \rho _{1} \rho _{2}\rho _{3} \ldots$ (où $\rho _{0},  \rho _{1},\ldots \in V$)  représentera un jeu et de manière similaire, pour une histoire $h$, $ h = h_{0} h_{1} h_{2} h_{3} ... h_{k}$ ( pour un certain $k \in \mathbb{N}$) où  $h_{0}, h_{1}, \ldots \in V$.
Un \textit{préfixe} de longueur $n+1$ (pour un certain $n\in \mathbb{N}$) d'un jeu $\rho = \rho _{0}  \rho _{1} \rho _{2}\rho _{3} \ldots$ est une histoire $\rho _{0}  \rho _{1} \rho _{2}\rho _{3} \ldots \rho _{n}$ et est notée $\rho[0,n]$. Soit $ h = h_{0} h_{1} \ldots h_{k}$ une histoire et soit $v \in V$ tel que $(h_{k},v)\in E$ on note $hv$ l'histoire $h_{0} h_{1} \ldots h_{k}v$. De même, étant donné une histoire $ h = h_{0} h_{1} h_{2} h_{3} ... h_{k}$ et un jeu $\rho = \rho _{0}  \rho _{1} \rho _{2} \ldots$ tels que $(h_{k},\rho_{0})\in E$ on note $h\rho$ le jeu $ h_{0} h_{1} \ldots h_{k}\rho _{0}  \rho _{1} \rho _{2} \ldots$ .

Etant donné une histoire $ h = h_{0} h_{1} h_{2} h_{3} ... h_{k}$,  on définit une fonction \textit{Last}(respectivement \textit{First}) qui prend comme argument l'histoire $h$ et qui retourne le dernier sommet $h_{k}$ (respectivement le premier sommet $h_{0}$).Nous définissons l'ensemble des histoires telles que c'est au tour du joueur $i \in \Pi$ de prendre une décision $Hist_{i} = \{ h \in Hist | Last(h) \in V_{i} \}$.

\begin{rem}
	Si un sommet initial $v_{0}$ a été fixé alors tous les jeux (et toutes les histoires) commencent par le sommet $v_{0}.$\\
\end{rem}

%--------------------------------------
% Définition de stratégie + stratégie consistante +  profil de stratégie + outcome
%--------------------------------------

\begin{defi}[Stratégie]
	Une \textit{stratégie} d'un joueur $i \in \Pi$ dans $\mathscr{A}$ est une fonction \mbox{$\sigma:Hist_{i} \rightarrow V$} telle que à chaque histoire $ h = h_{0} h_{1} h_{2} h_{3} ... h_{k}$ pour laquelle $h_{k} \in V_{i}$ est associée un sommet $v \in V$. De plus, on a: $(Last(h),\sigma(h))\in V$.
\end{defi}

\begin{defi}[Jeu consistant]	
	Un jeu $\rho = \rho _{0}  \rho _{1} \ldots$ est dit \textit{consistant} avec une stratégie $\sigma _{i}$ du joueur $i$ si pour tout préfixe $p = \rho _{0}\rho _{1}\ldots \rho _{k}$ (pour un certain $k \in \mathbb{N}$) tel que $p \in Hist_{i}$ on a : $\sigma _{i}(p) = \rho_{k+1}$.	
\end{defi}

\begin{rem}
	La notion de jeu consistant est facilement adaptable à la notion d'\textit{histoire consistante}.
\end{rem}

\begin{notations}
	Tout au long de ce rapport nous utilisons les conventions suivantes:
	\begin{enumerate}
		\item[$\bullet$] Un \textit{profil de stratégies} $(\sigma _{i})_{i \in \Pi}$ est un tuple tel que pour tout $i$ $\sigma _{i}$ désigne la stratégie du 	joueur $i$. 
				
		\item[$\bullet$] Soit  $(\sigma _{i})_{i \in \Pi}$ un profil de stratégies, pour un certain joueur $j\in \Pi $ on note $(\sigma _{i})_{i \in \Pi} = ( \sigma _{j},\sigma _{-j})$ .
		
		\item[$\bullet$] A un profil de stratégie $(\sigma _{i})_{i \in \Pi}$ et à un sommet initial $v_{0}$ est associé un unique jeu $\rho$ qui est consistant avec toutes les stratégies $\sigma _{i}$. Ce jeu est appelé \textit{outcome} de $\sigma _{i}$ et est noté $Outcome(v_{0},(\sigma _{i})_{i\in \Pi})$.
		
		\item[$\bullet$] On note $\Sigma _{i}$ l'ensemble des stratégies de $J_{i}$.
		
	\end{enumerate}
\end{notations}
		



%----------------------------------------
%Stratégie sans mémoire et avec mémoire
%----------------------------------------
\noindent\textbf{Stratégie avec mémoire vs. stratégie sans mémoire}\\



Lorsque l'on cherche des stratégies pour un joueur $J_{i}$, on distingue les \textit{stratégies sans mémoire},\textit{stratégie avec mémoire finie} et les \textit{stratégie avec mémoire infinie}.

\begin{defi}[Stratégie sans mémoire]
	
	Une stratégie $\sigma _{i} \in \Sigma _{i}$ est une \textit{stratégie sans mémoire} si le choix du prochain sommet dépend uniquement du sommet courant (ie. $\sigma _{i}: V_{i} \rightarrow V$).
\end{defi}

\begin{defi}[Stratégie à mémoire finie]
	
	Une stratégie $\sigma _{i} \in \Sigma _{i}$ est une \textit{stratégie à mémoire finie} si on peut lui associer un \textit{automate de Mealy} $\mathcal{A} = (M, m_{0}, V, \delta, \nu)$ où:
	\begin{enumerate}
		\item[$\bullet$] $M$ est un ensemble fini non vide d'états de mémoire,
		\item[$\bullet$] $m_{0} \in M$ est l'état initial de la mémoire,
		\item[$\bullet$] $\delta : M \times V \rightarrow M$ est la fonction de mise à jour de la mémoire,
		\item[$\bullet$] $ \nu: M \times V_{i} \rightarrow V$ est la fonction de choix, telle que pour tout $m \in M$ et $v\in V_{i}$ $(v, \nu(m,v))\in E$.\end{enumerate}
		
		On peut étendre la fonction de mise à jour de la mémoire à une fonction $\delta ^{*}: M \times Hist \rightarrow$ définie par récurrence sur la longueur de $h \in Hist$ de la manière suivante :\\ $\begin{cases}
																	\sigma^{*}(m,\epsilon) = m	\\
																	\sigma^{*}(m,hv)=\sigma(\sigma^{*}(m,h),v) & \text{pour tout } m\in M \text{ et } hv\in Hist
																	\end{cases}$ 
																	
		La stratégie $\sigma _{\mathcal{A}_{i}}$ calculée par un automate fini $\mathcal{A}_{i}$ est définie par $\sigma _{\mathcal{A}_{i}}(hv) = \nu(\delta^{*}(m_{0},h),v)$ pour tout $hv \in Hist_{i}$ . Cela signifie qu'à chaque fois qu'une décision est prise, la mémoire est modifiée en conséquence et que chaque nouvelle décision est prise en fonction de la mémoire enregistrée jusque maintenant.
		Dès lors on dit que $\sigma _{i}$ est une stratégie à mémoire finie s'il existe un automate fini $\mathcal{A}_{i}$ tel que $\sigma = \sigma _{\mathcal{A}_{i}}$.		

\end{defi}

\begin{defi}[Stratégie à mémoire infinie]
	
	Une stratégie $\sigma _{i} \in \Sigma _{i}$ est une \textit{stratégie à mémoire finie } si elle n'est ni sans mémoire ni à mémoire finie.
\end{defi}
